@tool
## Generates noise on GPU using the GLSL version [FastNoiseLite] library.
##
## This class generates noise using the GLSL version [FastNoiseLite] library,
## which is a collection of several noise algorithms including Cellular, Perlin, Value, and more.[br]
## This class has three main benefits agains bulit-in [NoiseTexture2D] and [NoiseTexture3D] classes:[br][br]
## [b]First:[/b] It calculates noise values using GPU device and can provide data at runtime.[br](much faster than CPU)[br][br]
## [b]Second:[/b] Working with [NoiseTexture3D] class may require [code]A LOT[/code] of memory to keep it's data.[br]
## For example [code]1024x1024x1024[/code] [NoiseTexture3D] will require more than [code]300 Mib[/code] on your disc or RAM, because it saves each pixel of 3D texture.
## With [FastNoiseLiteShaderMaterial] all values of the noise will be keept in GPU memory, [code]ONLY[/code] if they are used by [Mesh] or other object you need to render.[br][br]
## [b]Third:[/b] [NoiseTexture3D] and [NoiseTexture2D] are limited by "resolution" parameter. Shaders avoid that limitation, so noise generated by shader will be [b]EXTREMLY[/b] detailed![br][br]
## [b]WARNING:[/b] Usualy shader compilation takes less than 1 second but the more funcions of libruary you need - the more time engine need to compile the shader.[br]
## Enabling [code]Domain Warp[/code], for example, may add 1 second to shader compilation time.[br]
## Once shader got compiled it saves it self into [code]shader_cache[/code] and will not be compilled again until you delete [FastNoiseLiteShaderMaterial] node or relaunch the project.[br]
## Keep that things in mind and don't be afraid of little freezes.[br][br]
## [b]WARNING:[/b] Results are 99.9% equal to results provided by C++ libruary, but [code]DO NOT[/code] try to get values from [NoiseTexture2D] or [NoiseTexture3D] classes![br]
## The result will be corrupted by texture resolution! To avoid that use [FastNoiseLite] object directly.
class_name FastNoiseLiteShaderMaterial extends ShaderMaterial

#region ToolInterface
@export_group("Shader Settings")
## Type of the [Shader] that sets it's work mode:[br][br]
## [b]Note:[/b] How it will look in shader code:[br]
## [b] shader_type[/b] <value>[b];[/b][br][b]    [/b]**code**
@export_enum("Canvas Item","Spatial") var shader_type := 1:
	set(value):
		shader_type = value
		update_shader_defines()
## Type of the NoiseTexture class that shader will try to emulate.[br]
@export_enum("2D","3D") var texture_type := 0:#DEFINE CHANGE
	set(value):
		texture_type = value
		notify_property_list_changed()
		update_shader_defines()
## UVW - 3D UV of the texture.[br][br]
## [b]  X[/b] - [member width] scale.[br]
## [b]  Y[/b] - [member depth] scale (unused in canvas_item mode).[br]
## [b]  Z[/b] - [member heigth] scale.[br][br]
## [b]Note:[/b] In 2D mode [code]V[/code] component of [b]UV[/b] map controlled by [b]Z[/b].[br][br]
## [b]Note:[/b] In [code]canvas_item[/code] works as texture ([Polygon2D]) resolution.
@export var texture_uvw := Vector3(1,1,1):
	set(value):
		texture_uvw = value
		set_shader_parameter("uvw",value)
## Color chanel that shader will use for noise data output.[br][br]
## [b] ALL[/b] - default mode, returns result similar to NoiseTexture's output.[br]
## [b] RED[/b] - write noise data to [code]RED[/code] color chanel.[br]
## [b] GREEN[/b] - write noise data to [code]GREEN[/code] color chanel.[br]
## [b] BLUE[/b] - write noise data to [code]BLUE[/code] color chanel.[br]
## [b] ALPHA[/b] - write noise data to transparency chanel.
@export_enum("ALL","RED","GREEN","BLUE","ALPHA") var output := 0:
	set(value):
		output = value
		set_shader_parameter("output",value)
@export_group("Noise Texture")
## Width of the generated texture (in pixels).
@export_range(1, 2048, 1, "or_greater", "suffix:px") var width := 512:
	set(value):
		width = value
		set_shader_parameter("wdh",Vector3(width,heigth,depth))
## Heigth of the generated texture (in pixels).
@export_range(1, 2048, 1, "or_greater", "suffix:px") var heigth := 512:
	set(value):
		heigth = value
		set_shader_parameter("wdh",Vector3(width,heigth,depth))
## Depth of the generated texture (in pixelsuvw).
@export_range(1, 2048, 1, "or_greater", "suffix:px") var depth := 512:
	set(value):
		depth = value
		set_shader_parameter("wdh",Vector3(width,heigth,depth))
## If [code]true[/code], inverts the noise texture. White becomes black, black becomes white.
@export var invert := false:
	set(value):
		invert = value
		set_shader_parameter("invert",value)
## Determines whether the noise image is calculated in 3D space. May result in reduced contrast.
@export var in_3d_space :=false:#DEFINE CHANGE
	set(value):
		in_3d_space = value
		update_shader_defines()
## Determines whether mipmaps are generated for this texture. Enabling this results in less texture aliasing in the distance, at the cost of increasing memory usage by roughly 33% and making the noise texture generation take longer.[br][br]
## [b]Note:[/b] [member generate_mipmaps] requires mipmap filtering to be enabled on the material using the NoiseTexture2D to have an effect.[br][br]
## [b]WARNING:[/b] Can't be done with currend shader version...
@export var generate_mipmaps := false:#NOT IMPLEMENTED
	set(value):
		push_error("Generate Mipmaps: Not implemented!")
## If [code]true[/code], a seamless texture is requested from the [FastNoiseLite] resource.[br][br]
## [b]Note:[/b] Seamless noise textures may take longer to generate and/or can have a lower contrast compared to non-seamless noise depending on the used [Noise] resource. This is because some implementations use higher dimensions for generating seamless noise.[br][br]
## [b]Note:[/b] The default [FastNoiseLite] implementation uses the fallback path for seamless generation. If using a [member width] or [member height] lower than the default, you may need to increase [member seamless_blend_skirt] to make seamless blending more effective.
@export var seamless :=false:#DEFINE CHANGE
	set(value):
		seamless = value
		notify_property_list_changed()
		update_shader_defines()
## Used for the default/fallback implementation of the seamless texture generation. It determines the distance over which the seams are blended. High values may result in less details and contrast. See [Noise] for further details.[br][br]
## [b]Note:[/b] If using a [member width] or [member height] lower than the default, you may need to increase seamless_blend_skirt to make seamless blending more effective.
@export_range(0,1,0.001) var seamless_blend_skirt := 0.1:
	set(value):
		seamless_blend_skirt = value
		if (seamless): set_shader_parameter("seamless_blend_skirt",value)
## If [code]true[/code], the resulting texture contains a normal map created from the original noise interpreted as a bump map.
@export var as_normal_map := false:#DEFINE CHANGE
	set(value):
		as_normal_map = value
		notify_property_list_changed()
		update_shader_defines()
## Strength of the bump maps used in this texture. A higher value will make the bump maps appear larger while a lower value will make them appear softer.
@export_range(0,32,0.1,"or_greater") var bump_strength := 8:
	set(value):
		bump_strength = value
		if (as_normal_map): set_shader_parameter("bump_strength",value)
## If [code]true[/code], the noise image coming from the noise generator is normalized to the range 0.0 to 1.0.[br][br]
## Turning normalization off can affect the contrast and allows you to generate non repeating tileable noise textures.[br][br]
## [b]WARNING:[/b] Unused! Extremly expensive calculations per pixel! This can't be done on GPU device.[br][br]
## [b]Note:[/b] Will be avaliable in future versions of plugin BUT will be calculated on CPU.
@export var normalize := false:#NOT IMPLEMENTED
	set(value):
		push_error("Normalize: Not implemented!")
## A [Gradient] which is used to map the luminance of each pixel to a color value.
@export var color_ramp : Gradient:
	set(value):
		color_ramp = value
		var gdt = GradientTexture1D.new()
		gdt.gradient = value
		set_shader_parameter("color_ramp",gdt if value else null)
## Donor instance of the [FastNoiseLite] object.[br][br]
## [b]Note:[/b] Used only to provide noise parameters for more than one object.
@export var noise : FastNoiseLite:
	set(value):
		if noise:#disconnect old function
			noise.changed.disconnect(on_noise_update)
		noise = value
		if value:#connect to new value
			value.changed.connect(on_noise_update)
			on_noise_update()
#endregion

func _validate_property(property):
	if property.name == "generate_mipmaps" or property.name == "normalize":
		property.usage = PROPERTY_USAGE_READ_ONLY | PROPERTY_USAGE_EDITOR
	if  property.name == "shader" or (property.name == "depth" and texture_type==0)or(
		property.name == "seamless_blend_skirt" and not seamless) or (
		property.name == "bump_strength" and (not as_normal_map or texture_type==1)) or (
		property.name == "in_3d_space" and texture_type==1) or (
		property.name == "as_normal_map" and texture_type==1):
			property.usage = PROPERTY_USAGE_NO_EDITOR

func _init():
	shader = Shader.new()
	update_shader_defines()
	if Engine.is_editor_hint():#required to allow user set noise some values without problems
		shader.set_block_signals(true)

#region Shader Controler
## Key that used to identify the shader
var current_key := 0

## Key maker function that updates [member current_key]. Also returns [member current_key].
func make_key()->int: #stack all values into one integer (Shader ID)
	current_key = ((((((((noise.noise_type << 2 | noise.fractal_type) << 2 | noise.domain_warp_type) << 2 | noise.domain_warp_fractal_type)  << 1 | texture_type) << 1 | int(in_3d_space))<< 1 | int(noise.domain_warp_enabled))<<1 | int(seamless))<<1 | int(as_normal_map))<<1 | int(shader_type)
	return current_key

## Called when need to recompile shader.
func update_shader_defines():
	if noise:
		##Make new shader code
		var base = """shader_type %s
#define DEFINE_OVERRIDE
#define SELECTED_NOISE_TYPE %d
#define SELECTED_FRACTAL_TYPE %d
#define SELECTED_DOMAIN_WARP_TYPE %d
#define SELECTED_DOMAIN_WARP_FRACTAL_TYPE %d
#define FNL_COMPILLER_OPTIMISATIONS_REQUIRED
#include "res://addons/FastNoiseLiteRuntimeShader/FastNoiseLiteLib.gdshaderinc"
#define IS_3D_TEXTURE %s
#define IN_3D_SPACE %s
#define DOMAIN_WARP_ENABLED %s
#define SEAMLESS %s
#define AS_NORMAL_MAP %s
#define NO_GROUPS
#include "res://addons/FastNoiseLiteRuntimeShader/FastNoiseLiteBase.gdshaderinc"
""" % ([#noise types and args
		"canvas_item;\n#define CANVAS_ITEM" if shader_type==0 else "spatial;\nrender_mode depth_prepass_alpha,cull_back,depth_draw_always;",
		noise.noise_type, 
		noise.fractal_type,
		noise.domain_warp_type,
		noise.domain_warp_fractal_type if noise.domain_warp_fractal_type==0 else noise.domain_warp_fractal_type+3,
		#define-zated shader uniforms
		true if texture_type==1 else false, 
		in_3d_space, 
		noise.domain_warp_enabled, 
		seamless, 
		as_normal_map])
		## Set new shader code
		shader.code = base

## Update noise parameters when noise object was changed.
func on_noise_update():
	## Lambda function to set nev value only if needed.
	var set_param_if_changed = func(param,value):
		var old = get_shader_parameter(param)
		if old != value:
			set_shader_parameter(param,value)
	## Recompile shader only if needed.
	var old_key = current_key
	var key = make_key()
	if old_key != key:
		update_shader_defines()
	## Sync shade uniforms with noise properties.
	set_param_if_changed.call("seed",noise.seed)
	set_param_if_changed.call("frequency",noise.frequency)
	set_param_if_changed.call("offset",noise.offset)
	set_param_if_changed.call("octaves",noise.fractal_octaves)
	set_param_if_changed.call("lacunarity",noise.fractal_lacunarity)
	set_param_if_changed.call("gain",noise.fractal_gain)
	set_param_if_changed.call("weighted_strength",noise.fractal_weighted_strength)
	if noise.fractal_type == FastNoiseLite.FRACTAL_PING_PONG:
		set_param_if_changed.call("ping_pong_strength",noise.fractal_ping_pong_strength)
	if noise.noise_type == FastNoiseLite.TYPE_CELLULAR:
		set_param_if_changed.call("distance_function",noise.cellular_distance_function)
		set_param_if_changed.call("jitter",noise.cellular_jitter)
		set_param_if_changed.call("return_type",noise.cellular_return_type)
	if noise.domain_warp_enabled:
		set_param_if_changed.call("amplitude",noise.domain_warp_amplitude)
		set_param_if_changed.call("_frequency",noise.domain_warp_frequency)
		set_param_if_changed.call("fractal_octaves",noise.domain_warp_fractal_octaves)
		set_param_if_changed.call("fractal_lacunarity",noise.domain_warp_fractal_lacunarity)
		set_param_if_changed.call("fractal_gain",noise.domain_warp_fractal_gain)
#endregion
